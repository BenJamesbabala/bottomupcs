<chapter id="wk5">
  
  <title>Virtual Memory</title>

  <sect1>
    <title>What Virtual Memory <emphasis>isn't</emphasis></title>

    <para>Virtual memory is often naively discussed as a way to
    extended your RAM by using the hard drive as extra, slower, system
    memory.  That is, once your system runs out of memory, it flows
    over onto the hard drive which is used as "virtual" memory.</para>

    <para>In modern operating systems, this is commonly referred to as
    <emphasis>swap space</emphasis>, because unused parts of memory as
    swapped out to disk to free up main memory (remember, programs can
    only execute from main memory).
    </para>

    <para>Indeed, the ability to swap out memory to disk is an
    important part of how virtual memory works, but as you will see it
    is not the purpose of virtual memory, but rather a very useful
    side effect!</para>

  </sect1>

  <sect1>
    <title>What virtual memory <emphasis>is</emphasis></title>
    
    <para>Virtual memory is all about making use of <emphasis>address
    space</emphasis>.</para>

    <para>The address space of a processor refers the range of
    possible addresses that it can use when loading and storing to
    memory.  The address space is limited by the width of the
    registers, since as we know to load an address we need to issue a
    <computeroutput>load</computeroutput> instruction with the address
    to load from in a register.  Most current processors have
    registers that are 32 bits wide; this means the addresses that can
    be stored in a register range from
    <computeroutput>0x00000000</computeroutput> to
    <computeroutput>0xFFFFFFF</computeroutput>.
    2^<superscript>32</superscript> is equal to 4GB, so a 32 bit
    processor can load or store to up to 4GB of memory.</para>

    <sect2>
      <title>64 bit computing</title>

      <para>Most new processors are moving towards 64 bit processors,
    which have registers 64 bits wide.  As an exercise, you should
    work out the address space available to these processors (hint:
    it's big!).</para>
    </sect2>

    <sect2>
      <title>Using the address space</title>
    
      <para>As with most components of the operating system, virtual
    memory acts as an abstraction between the address space and the
    physical memory available in the system.  This means that when a
    program uses an address that address does not refer to the bits in
    an actual physical location in memory, but must be translated by
    the operating system.</para>
      
    <para>So to this end, we say that all addresses the program uses
      are <emphasis>virtual</emphasis>.  The operating system keeps
      track of virtual addresses and how they point to
      <emphasis>physical address</emphasis>.  When a program does a
      load or store from an address, the processor and operating
      system work together to convert this virtual address to the
      actual address in the system memory chips.
      </para>

      <para>Over time, physical memory becomes
      <emphasis>fragmented</emphasis>, meaning that there are "holes"
      of free space in the physical memory.  Having to work around
      these holes would be at best annoying and would become a serious
      limit to programmers.  By using a virtual address that maps to
      an arbitrary physical address the programmer can leave working
      around fragmentation up to the operating system.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Pages</title>

    <para>The address space of even a 32 bit processor is quite large,
    and if the operating system is to keep track of it all it needs to
    divide it into more manageable parts.</para>

    <para>The operating system divides the address space into
    <emphasis>pages</emphasis>.  Pages can be many different sizes,
    generally they are around 4KB, but this is not a hard and fast
    rule and they can be much larger.</para>

    <para>The page is the smallest unit of memory that the operating
    system and hardware can deal with.</para>

    <para>Additionally, each page has a number of attributes set by
    the operating system.  Generally, these include read, write and
    execute permissions for the current page.  For example, a page
    must be marked if it contains executable code.</para>

    <figure>
      <title>Virtual memory pages</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="wk5/figures/page.eps" format="EPS">
	</imageobject>
	<imageobject>
	  <imagedata fileref="wk5/figures/page.png" format="PNG">
	</imageobject>
	<textobject>
	  <phrase>Pages point to physical memory</phrase>
	</textobject>
      </mediaobject>
    </figure>

  </sect1>

  <sect1>
    <title>Physical Memory</title>

    <para>Just as the operating system divides the possible address
    space up into pages, it divides the available physical memory up
    into <emphasis>frames</emphasis>.</para>

    <para>A frame is just a hunk of physical memory the same size as
    the system page size.</para>

  </sect1>

  <sect1>
    <title>Pages + Frames = Page Tables</title>

    <para>The job of the operating system is to keep track of which
    page points to which frame.  This information is kept in a
    <emphasis>page table</emphasis> which, in its simplest form, is
    simply a table where each row has a page and an associated
    frame.</para>

    <para>With a 32 bit address space and 4K pages there will be
      1048576 pages in the page table.  Assuming each entry in the
      page table takes up 32 bits (or 4 bytes) we have 1048576 * 4 ==
      4194304 bytes == 4MB of page table data to map the entire
      address space. </para>
    
    <para>Page tables can have many different structures and are
      generally highly optimised, as the process of finding a page in
      the page table can be a lengthly process.</para>

  </sect1>

  <sect1>
    <title>Virtual Adresses</title>

    <para>When a program accesses memory, it does not know or care
    where the physical memory backing the address is stored.  It knows
    it is up to the operating system to map the address to the right
    place and provide it with the data it wants.</para>

    <para>We call the address the userspace program is using to access
    memory a <emphasis>virtual address</emphasis>.  The virtual
    address consists of two parts; an index to a page in a page table
    and an offset.</para>

    <sect2>
      <title>Page Index</title>

      <para>The index portion of the virtual address is the index
      into the page table.</para>
    </sect2>

    <sect2>
      <title>Offset</title>

      <para>The last bits of the virtual address are called the
      <emphasis>offset</emphasis> which is the location within the
      physical page of the address.  You require enough bits in the
      offset to be able to get to any byte in the page.  For a 4K page
      you require (4K == (4 * 1024) == 4096 ==
      2<superscript>12</superscript> ==) 12 bits.</para>

    </sect2>

    <sect2>
      <title>Virtual Address Translation</title>

      <para>When the operating system needs to find the actual memory
      behind a virtual address, it firstly takes the page pointer
      component of the address and looks it up in the page table.
      This gives a pointer to a physical address, to which the offset
      from the virtual address is added, giving the actual location in
      memory.</para>

      <figure>
	<title>Virtual Address Translation</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="wk5/figures/virtaddress.eps" format="EPS">
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="wk5/figures/virtaddress.png" format="PNG">
	  </imageobject>
	  <textobject>
	    <phrase>Converting a virtual address to a physical address</phrase>
	  </textobject>
	</mediaobject>
      </figure>

    </sect2>
  </sect1>


  <sect1>
    <title>Consequences of virtual addresses, pages and page tables</title>

    <para>Virtual addressing, pages and page tables opens up a number
    of interesting opportunities for the operating system.</para>

    <sect2>
      <title>Individual address spaces</title>
      
      <para>If the operating system gives each process its own page
	table, then every process can pretend that it has access to
	the entire address space available from the processor.  It
	doesn't matter that two processes might use the same address,
	since the page table will map it to a different place in
	physical memory.  Every modern operating system provides each
	process with its own address space like this.</para>
    </sect2>

    <sect2>
      <title>Swap</title>

      <para>We can also now see how the swap memory is implemented.
      If instead of pointing to an area of system memory the page
      pointer can be changed to point to a location on a
      disk.</para>

      <para>When this page is referenced, the operating system needs
      to move it from the disk back into system memory (remember,
      program code can only execute from system memory).  If system
      memory is full, then <emphasis>another</emphasis> page needs to
      be kicked out of system memory and put into the swap disk before
      the required page can be put in memory.  If another process
      wants that page that was just kicked out back again, the process
      repeats.</para>

      <para>This can be a major issue for swap memory.  Loading from
      the harddisk is very slow (compared to operations done in
      memory) and most people will be familiar with sitting in front of
      the computer whilst the hard disk churns and churns whilst the
      system remains unresponsive.</para>

      <sect3>
	<title>mmap</title>

	<para>A different but related process is the memory map, or
	<computeroutput>mmap</computeroutput> (from the system call
	name).  If instead of the page table pointing to physical
	memory or swap the page table points to a file, on disk, we
	say the file is
	<computeroutput>mmap</computeroutput>ed.</para>

	<para>Normally, you need to
	<computeroutput>open</computeroutput> a file on disk to obtain
	a file descriptor, and then
	<computeroutput>read</computeroutput> and
	<computeroutput>write</computeroutput> it in a sequential
	form.  When a file is mmaped it can be accessed just like
	system RAM.  
	</para>

      </sect3>

    </sect2>
  
    <sect2>
      <title>Sharing memory</title>

      <para>Usually, each process gets its own page table, so any
      address it uses is mapped to a unique frame in physical memory.
      But what if the operating system points two page table entries
      to the same frame?  This means that this frame will be shared;
      and any changes that one process makes will be visible to the
      other.</para>

      <para>You can see now how threads are implemented.  Remember
      from previously we said that the Linux
      <computeroutput>clone()</computeroutput> function could share as
      much or as little of a new process with the old process as it
      required.  If a process calls
      <computeroutput>clone()</computeroutput> to create a new
      process, but requests that the two processes share the same page
      table, then you effectively have a <emphasis>thread</emphasis>
      as both processes see the same underlying physical
      memory.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Hardware Support</title>

    <para>So far, we have only mentioned that hardware works with the
    operating system to implement virtual memory.  However we have
    glossed over the details of exactly how this happens.</para>

    <para>Virtual memory is necessarily quite dependent on the
    hardware architecture, and each architecture has its own
    subtleties.  However, there are are a few universal
    elements to virtual memory in hardware.</para>

    <sect2>
      <title>Physical v Virtual Mode</title>

      <para>All processors have some concept of either operating is
      <emphasis>physical</emphasis> or <emphasis>virtual</emphasis>
      mode.  In physical mode, the hardware expects that any address
      will refer to an address in actual system memory.  In virtual
      mode, the hardware knows that addresses will need to be
      translated to find their physical address.</para>

      <para>In many processors, this two modes are simply refered to
      as physical and virtual mode.  Itanium is one such example.  The
      most common processor, the x86, has a lot of baggage from days
      before virtual memory and so the two modes are referred to as
      <emphasis>real</emphasis> and <emphasis>protected</emphasis>
      mode.  The first processor to implement protected mode was the
      386, and even the most modern processors in the x86 family line
      (Pentiums) can still do real mode, though it is not used.  In
      real mode the processor implements a form of memory organisation
      called segmentation.</para>

      <sect3>
	<title>Segmentation</title>

	<para>Segmentation is really only interesting as a historical
	note, since virtual memory has made it less relevant.
	Segmentation has a number of drawbacks, not the least of which
	it is very confusing for inexperienced programmers, which
	virtual memory systems were largely invented to get around.
	</para>

	<para>In segmentation there are a number of registers which
	hold an address that is the start of a segment.  The size of
	the segment is determined by the number of bits available to
	offset from segment base register.  In the x86, the maximum
	offset is 16 bits, or only 64K.  This causes all sorts of
	havoc if one wants to use an address that is more than 64K
	away, which as memory grew into the megabytes (and now
	gigabytes) became more than a slight inconvience to a complete
	failure.
	</para>

	<figure>
	  <title>Segmentation</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="wk5/figures/segmentation.eps" format="EPS">
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="wk5/figures/segmentation.png" format="PNG">
	    </imageobject>
	    <textobject>
	      <phrase>A segmentation problem.  You only have three
	      segment registers, and can only offset a short distance
	      from each segment.  How do you get to another address?
	      You need to manually reorganise the segment registers,
	      which quickly becomes a bottleneck.</phrase>
	    </textobject>
	  </mediaobject>
	</figure>

	<para>In the above figure, there are three segment registers
	which are all pointing to segments.  The maxiumum offset
	(constrained by the number of bits available) is shown by
	shading.  If the program wants an address outside this range,
	the segment registers must be reconfigured.  This quickly
	becomes a major annoyance.  Virtual memory, on the other hand,
	allows the program to specify any address and the operating
	system and hardware do the hard work of translating to a
	physical address.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>The TLB</title>

      <para>The <emphasis>Translation Lookaside Buffer</emphasis> (or
      TLB for short) is analogous to a page table inside the CPU.  The
      operating system and hardware work together to manage the
      TLB as the system runs.</para>

      <para>The TLB, being implemented in hardware, is necessarily
      small and can not contain a copy of the entire page table.  It
      needs to be managed by the operating system.
      </para>

      <sect3>
	<title>Page Faults</title>

	<para>When a virtual address is requested of the hardware, it
	processor looks it up in the TLB, and if it has a translation
	can use the offset to go straight to the physical
	address.</para>

	<para>If the processor can <emphasis>not</emphasis> find a
	translation in the TLB, the processor must raise a
	<emphasis>page fault</emphasis>.  This is an interrupt (as
	discussed before) which the operating system must
	handle.</para>

	<para>When the operating system gets a page fault, it needs to
	go through the page table in memory to find the correct
	translation and insert it into the TLB.</para>

	<para> In the case that the operating system can not find a
	translation in the page table, or alternatively if the
	operating system checks the permissions of the page in
	question and the process is not authorised to view it, the
	operating system must kill the process.  If you have ever seen
	a segmentation fault (or a segfault) this is the operating
	system killing a process that has overstepped its
	bounds.</para>

	<para>Should the translation be found, and the TLB currently
	be full, then one translation needs to be removed before
	another can be inserted.  It does not make sense to remove a
	translation that is likely to be used in the future, as you
	will incur the cost of finding the entry in the page tables
	all over again.  TLBs usually use something like a
	<emphasis>Least Recently Used</emphasis> or LRU algorithm,
	where the oldest translation that has not been used is ejected
	in favour of the new one.</para>

	<para>The access can then be tried again, and, all going well,
	should be found in the TLB and translated correctly.</para>

      </sect3>

    </sect2>

  </sect1>

</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.sgml" "book" "chapter")
End:
-->