<chapter id="wk8">
  
  <title>Libraries and Dynamic Linking</title>

  <sect1>
    <title>Libraries</title>

    <para>Developers soon tired of having to write everything
      themselves from scratch, so one of the first inventions of
      computer science was <emphasis>libraries</emphasis>.</para>

    <para>A library is simply a collection of functions which you
      can call from your program.  Obviously a library has many
      advantages, not least of which is that you can save much time by
      reusing work someone else has already done and generally be more
      confident that it has fewer bugs (since probably many other
      people use the libraries too, and you benefit from having them
      finding and fixing bugs).  A library is exactly like an
      executable, except instead of running directly the library
      functions are invoked with parameters from your
      executable.</para>

  </sect1>

  <sect1>
    
    <title>Static Libraries</title>
	
    <para>When a library is linked right in to your executable, it's
      called a <emphasis>static</emphasis> library.  This has two main
      disadvantages; firstly if the library code is updated (to fix a
      bug, say) you have to recompile your program into a new
      executable and secondly every program in the system that uses
      that library contains a copy in it's executable, which is very
      inefficient (and a pain if you find a bug and have to recompile,
      as per point one).</para>

    <para>In fact, a static library is simply a group of object
	files in an <emphasis>archive</emphasis>.  This is a very
	simple format similar to a <command>zip</command> file.</para>

    <para>You can create archive files with the
	<command>ar</command> command (in fact, you can put any type
	of file in an <command>ar</command> archive, but generally it
	is only used with object files).  By convention static library
	file names are prefixed with
	<computeroutput>lib</computeroutput> and have the extension
	<computeroutput>.a</computeroutput>.  You then specify the
	library to the compiler with <option>-lname</option> where
	name is the filename of the library (you may need to provide
	an extra directory to search to the compiler with
	<option>-L</option>). XXX</para>

    <para>Below we show an example of creating a simple static
	library and linking it into an application.</para>

  </sect1>

  <sect1>

    <title>Dynamic Libraries</title>

    <para>We know that for the operating system code is considered
      read only, and separate from data.  It seems logical then that
      if programs can not modify code and have large amounts of common
      code, instead of replicating it for every executable it should
      be shared between many executables.</para>

    <para>With virtual memory this can be easily done.  The physical
      pages of memory the library code is loaded into can be easily
      referenced by any number of virtual pages in any number of
      address spaces.  So while you only have one physical copy of the
      library code in system memory, every process can have access to
      that library code at any virtual address it likes.</para>
    
    <para>Thus people quickly came up with the idea of a
      <emphasis>shared library</emphasis> which, as the name suggests,
      is shared by multiple executables.  Each executable contains a
      reference essentially saying "I need library foo".  When the
      program is loaded, it is up to the system to either check if
      some other program has already loaded the code for library foo
      into memory, and thus share it by mapping pages into the
      executable for that physical memory, or otherwise load the
      library into memory for the executable.</para>

    <para>This process is called <emphasis>dynamic linking</emphasis>
    because it does part of the linking process "on the fly" as
    programs are executed in the system.</para>

    <sect2>
      <title>Dynamic Library Details</title>

      <para>Libraries are very much like a program that never gets
      started.  They have code and data sections (functions and
      variables) just like every executable; but no where to start
      running.  They just provide a library of functions for
      developers to call.e</para>

      <para>Thus ELF can represent a dynamic library just as it does
      an executable.  There are some fundamental differences, but all
      shared libraries are just ELF objects like any other
      executable.</para>

      <para>The ELF header has two mutually exclusive flags,
      <computeroutput>ET_EXEC</computeroutput> and
      <computeroutput>ET_DYN</computeroutput> to mark an ELF file as
      either an executable or a shared object file.</para>

    </sect2>

    <sect2>
      <title>Including libraries in an executable</title>

      <sect3>
	<title>Compilation</title>

	<para>When you compile your program that uses a dynamic
	library, object files are left with references to the library
	functions just as for any other external reference.</para>

	<para>You need to include the <emphasis>header</emphasis> for
	the library so that the compiler knows the specific types of
	the functions you are calling.  Note the compiler only needs
	to know the types associated with a function (such as, it
	takes an <computeroutput>int</computeroutput> and returns a
	<computeroutput>char *</computeroutput>) so that it can
	correctly allocate space for the function call.<footnote>
	<para>This has not always been the case with the C standard.
	Previously, compilers would assume that any function it did
	not know about returned an
	<computeroutput>int</computeroutput>.  On a 32 bit system, the
	size of a pointer is the same size as an
	<computeroutput>int</computeroutput>, so there was no problem.
	However, with a 64 bit system, the size of a pointer is
	generally twice the size of an
	<computeroutput>int</computeroutput> so if the function
	actually returns a pointer, its value will be destroyed.  This
	is clearly not acceptable, as the pointer will thus not point
	to valid memory.  The C99 standard has changed such that you
	are required to specify the types of included
	functions.</para></footnote></para>

      </sect3>

      <sect3>
	<title>Linking</title>

	<para>Even though the <emphasis>dynamic linker</emphasis> does
	a lot of the work for shared libraries, the traditional linker
	still has a role to play in creating the executable.</para>

	<para>The traditional linker needs to leave a pointer in the
	executable so that the dynamic linker knows what library will
	satisfy the dependencies at runtime.</para>

	<para>The <computeroutput>dynamic</computeroutput> section of
	the executable requires a
	<computeroutput>NEEDED</computeroutput> entry for each shared
	library that the executable depends on.</para>

	<para>Again, we can inspect these fields with the
	<computeroutput>readelf</computeroutput> program.  Below we
	have a look at a very standard binary,
	<computeroutput>/bin/ls</computeroutput></para>

	<example>
	  <title>Specifying Dynamic Libraries</title>
	  <programlisting linenumbering="numbered" lang="C"><inlinemediaobject>
	      <imageobject>
		<imagedata fileref="wk8/code/dynamic-needed.txt" format="linespecific">
	      </imageobject>
	    </inlinemediaobject></programlisting>
	</example>


	<para>You can see that it specifies three libraries.  The most
	common library shared by most, if not all, programs on the
	system is <computeroutput>libc</computeroutput>.  There are
	also some other libraries that the program needs to run
	correctly.</para>

	<para>Reading the ELF file directly is sometimes useful, but
	the usual way to inspect a dynamically linked executable is
	via <computeroutput>ldd</computeroutput>.
	<computeroutput>ldd</computeroutput> "walks" the dependencies
	of libraries for you; that is if a library depends on another
	library, it will show it to you.</para>

	<example>
	  <title>Looking at dynamic libraries</title>
	  <programlisting linenumbering="numbered" lang="C"><inlinemediaobject>
	      <imageobject>
		<imagedata fileref="wk8/code/ldd.txt" format="linespecific">
	      </imageobject>
	    </inlinemediaobject></programlisting>
	</example>


	<para>We can see above that
	<computeroutput>libpthread</computeroutput> has been required
	from somewhere.  If we do a little digging, we can see that
	the requirement comes from
	<computeroutput>librt</computeroutput>.</para>

      </sect3>

    </sect2>

  </sect1>

  <sect1>
    <title>Position Independent Code</title>

    <para>We mentioned that shared libraries look a lot like
    executables in terms of common ELF structures, but there were some
    fundamental differences.</para>

    <para>The biggest, and most important, difference is called
    <emphasis>position independent code</emphasis>, or PIC.</para>

    <para>When an executable file is created, the code and data
    segment is given a specified base address in virtual memory.  When
    the executable is loaded and run, you can be sure that the code
    and data will be where you expect.</para>

    <para>This guarantee can be granted because each time an
    executable is run it will be in its own process, which has its own
    view of a fresh address space thanks to virtual memory.</para>

    <para>The result of this is that the compiler knows the address of
    all code and data so can pre-compute all accesses.</para>

    <para>Shared libraries, however, have no such guarantee about a
    base address.  This is a fundamental problem; the shared library
    may be used by any process that may also load any other number of
    shared libraries.  If two shared libraries were to specify the
    same address and one were already loaded, there could be no
    resolution.</para>

    <para>Thus all libraries must be produced with code that can
    execute no matter where it is put into memory (or, position
    independent code).  Note that the data section is still a fixed
    offset from the code section; but to actually find the address of
    data the offset needs to be added to the load address.</para>

    <para>Below we explain the mechanisms for doing this.</para>


    <sect2>
      <title>Relocations</title>

      <para>The essential part of PIC is fixing up addresses at
      runtime, which is the only time you can know for certain where
      you are loaded in memory.  A relocation can simply be thought of
      as a note that a particular address will need to be fixed at
      load time.  Before the code is ready to run you will need to go
      through and read all the relocations and fix the addresses it
      refers to to point to the right place.</para>

      <table>
	<title>Relocation Example</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Address</entry>
	      <entry>Action</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>0x123456</entry>
	      <entry>Address of symbol "x"</entry>
	    </row>
	    <row>
	      <entry>0x564773</entry>
	      <entry>Function X</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>There are many types of relocation for each architecture,
      and each types exact behaviour is documented as part of the ABI
      for the system.  The definition of a relocation is quite
      straight forward.</para>

      <example>
	<title>Relocation as defined by ELF</title>
	<programlisting linenumbering="numbered" lang="C"><inlinemediaobject>
	    <imageobject>
	      <imagedata fileref="wk8/code/elfrelocs.txt" format="linespecific">
	    </imageobject>
	  </inlinemediaobject></programlisting>
      </example>

      <para>The <computeroutput>r_offset</computeroutput> field refers
      to the offset in the file that needs to be fixed up.  The
      <computeroutput>r_info</computeroutput> field specifies the type
      of relocation which describes what exactly must be done to fix
      this code up.  The simplest relocation usually defined for an
      architecture is simply the value of the symbol.  In this case
      you simply substitute the address of the symbol at the location
      specified, and the relocation has been "fixed-up".</para>

      <para>The two types, one with an addend and one without specify
      different ways for the relocation to operate.  An addend is
      simply something that should be added to the fixed up address to
      find the correct address.  For example, if the relocation is for
      the symbol <computeroutput>i</computeroutput> because the
      original code is doing something like
      <computeroutput>i[8]</computeroutput> the addend will be set to
      8.  This means "find the address of
      <computeroutput>i</computeroutput>, and go 8 past it".</para>

      <para>That addend value needs to be stored somewhere.  The two
      solutions are covered by the two forms.  In the
      <computeroutput>REL</computeroutput> form the addend is actually
      store in the program code in the place where the fixed up
      address should be.  This means that to fix up the address
      properly, you need to first read the memory you are about to fix
      up to get any addend, store that, find the "real" address, add
      the addend to it and then write it back (over the addend).  The
      <computeroutput>RELA</computeroutput> format specifies the
      addend right there in the relocation.</para>

      <para>The trade offs of each approach should be clear.  With
      <computeroutput>REL</computeroutput> you need to do an extra
      memory reference to find the addend before the fixup, but you
      don't waste space in the binary becuase you use relocation
      target memory.  With <computeroutput>RELA</computeroutput> you
      keep the addend with the relocation, but waste that space in the
      on disk binary.  Most modern systems use
      <computeroutput>RELA</computeroutput> relocations.</para>

      <sect3>
	<title>Relocations in action</title>

	<para>The example below shows how relocations work.  We create
	two very simple shared libraries and reference one from in the
	other.</para>

	<example>
	  <title>Specifying Dynamic Libraries</title>
	  <programlisting linenumbering="numbered" lang="C"><inlinemediaobject>
	      <imageobject>
		<imagedata fileref="wk8/code/relocs.txt" format="linespecific">
	      </imageobject>
	    </inlinemediaobject></programlisting>
	</example>

	<para>We thus have one relocation in
	<computeroutput>addendtest.so</computeroutput> of type
	<computeroutput>R_IA64_DIR64LSB</computeroutput>.  If you look
	this up in the IA64 ABI, the acronym can be broken down to
	</para>

	<orderedlist>
	  <listitem>
	    <para><emphasis>R_IA64</emphasis> : all relocations start with this prefix.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>DIR64</emphasis> : a 64 bit direct type relocation</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>LSB</emphasis> : Since IA64 can operate in big and
	    little endian modes, this relocation is little endian
	    (least significant byte).</para>
	  </listitem>
	</orderedlist>

	<para>The ABI continues to say that that relocation means "the
	value of the symbol pointed to by the relocation, plus any
	addend".  We can see we have an addend of 8, since
	<computeroutput>sizeof(int) == 4</computeroutput> and we have
	moved two int's into the array (<computeroutput>*j = i +
	2</computeroutput>).  So at runtime, to fix this relocation
	you need to find the address of symbol
	<computeroutput>i</computeroutput> and put it's value, plus 8
	into <computeroutput>0x104f8</computeroutput>.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>The Global Offset Table</title>

      <para>You might have noticed a critical problem with relocations
      when thinking about the goals of a shared library.</para>

      <para>If you modify the code of a shared library with a
      relocation, that code no longer becomes sharable across the
      system.  Each process may load the library into a different
      place in virtual memory, but we can easily point those virtual
      pages at the same physical pages.  Once you start modifying the
      code to point to particular addresses you have lost sharability.
      Each process will require it's own in memory copy with the
      updated addresses.</para>

      <para>So imagine the situation where we take the value of a
      symbol.  With only relocations, we would have the dynamic linker
      look up the memory address of that symbol and re-write the code
      to load that address.</para>

      <para>A fairly straight forward enhancment would be to set aside
      space in our binary to hold the address of that symbol, and have
      the dynamic linker put the address there rather than in the code
      directly.  This way we never need to touch the code part of the
      binary.</para>

      <para>The area that is set aside for these addresses is called
      the Global Offset Table, or GOT.  The GOT lives in a section of
      the ELF file called <computeroutput>.got</computeroutput>.
      </para>

      <figure>
	<title>Memory access via the GOT</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="wk8/figures/got-plt.eps" format="EPS">
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="wk8/figures/got-plt.png" format="PNG">
	  </imageobject>
	  <textobject>
	    <phrase>To keep code (green) sharable, we define process
	    private areas to which we can store the addresses of
	    common variables.  This allows us to load the code
	    anywhere in the process address space whilst still sharing
	    the underlying physical pages.</phrase>
	  </textobject>
	</mediaobject>
      </figure>

      <para>The GOT is private to each process, and the process must
      have write permissions to it.  Conversley the library code is
      shared and the process should have only read and execute
      permissions on the code; it would be a serious security breach
      if the process could modify code.</para>

      <sect3>
	<title>The GOT in action</title>

	<example>
	  <title>Using the GOT</title>
	  <programlisting linenumbering="numbered" lang="C"><inlinemediaobject>
	      <imageobject>
		<imagedata fileref="wk8/code/got.txt" format="linespecific">
	      </imageobject>
	    </inlinemediaobject></programlisting>
	</example>

	<para>Above we create a simple shared library which refers to
	an external symbol.  We do not know the address of this symbol
	at compile time, so we leave it for the dynamic linker to fix
	up at runtime.</para>

	<para>But we want our code to remain sharable, in case other
	processes want to use our code as well.</para>

	<para>The disassembly reveals just how we do this with the
	<computeroutput>.got</computeroutput>.  On IA64 (the
	architecture which the library was compiled for) the register
	<computeroutput>r1</computeroutput> is known as the
	<emphasis>global pointer</emphasis> and always points to where
	the <computeroutput>.got</computeroutput> section is loaded
	into memory.</para>

	<para>If we have a look at the
	<computeroutput>readelf</computeroutput> output we can see
	that the <computeroutput>.got</computeroutput> section starts
	0x10570 bytes past where library was loaded into memory.  Thus
	if the library were to be loaded into memory at address
	0x6000000000000000 the <computeroutput>.got</computeroutput>
	would be at 0x6000000000010570, and register
	<computeroutput>r1</computeroutput> would always point to this
	address.</para>

	<para>Working backwards through the disassembly, we can see
	that we store the value 100 into the memory address held in
	register <computeroutput>r15</computeroutput>.  If we look
	back we can see that register 15 holds the value of the memory
	address stored in register 14.  Going back one more step, we
	see we load this address is found by adding a small number to
	register 1.  The GOT is simply a big long list of entries, one
	for each external variable.  This means that the GOT entry for
	the external variable <computeroutput>i</computeroutput> is
	stored 24 bytes (that is 3 64 bit addresses).
	</para>

	<example>
	  <title>Relocations against the GOT</title>
	  <programlisting linenumbering="numbered" lang="C"><inlinemediaobject>
	      <imageobject>
		<imagedata fileref="wk8/code/got-relocs.txt" format="linespecific">
	      </imageobject>
	    </inlinemediaobject></programlisting>
	</example>

	<para>We can also check out the relocation for this entry too.
	The relocation says "replace the value at offset 10588 with
	the memory location that symbol i is stored at".</para>

	<para>We know that the <computeroutput>.got</computeroutput>
	starts at offset 0x10570 from the previous output.  We have
	also seen how the code loads an address 0x18 (24 in decimal)
	past this, giving us an address of 0x10570 + 0x18 =
	0x10588 ... the address which the relocation is for!</para>

	<para>So before the program begins, the dynamic linker will
	have fixed up the relocation to ensure that the value of the
	memory at offset 0x10588 is the address of the global variable
	<computeroutput>i</computeroutput>!</para>

      </sect3>

    </sect2>

    <sect2>
      <title>The Procedure Lookup Table</title>

      <para>blah</para>

    </sect2>
  </sect1>

  <sect1>
    <title>The Dynamic Linker</title>

    <para>The dynamic linker is one of the most critical parts of a
    modern system.  </para>

  </sect1>

</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.sgml" "book" "chapter")
End:
-->