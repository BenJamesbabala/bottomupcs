<chapter id="wk1">
  
  <title>Binary and Number Representation</title>

  <sect1>
    <title>Binary -- the basis of computing</title>

    <sect2>
      <title>Binary Theory</title>

      <sect3>
	<title>Introduction</title> 

	<para>Binary is a number system which builds numbers from
	elements called <emphasis>bits</emphasis>.  Each bit can be
	represented by any two mutually exclusive states.  Generally,
	when we write it down or code bits, we represent them with
	<computeroutput>1</computeroutput> and
	<computeroutput>0</computeroutput>.  We also talk about them
	being true and false, and the computer internally represents
	bits with high and low voltages.</para>
      
	<para>We build binary numbers the same way we build numbers in
	our traditional base 10 system.  However, instead of a one's
	column, a 10's column, a 100's column (and so on) we have a
	one's column, a two's columns, a four's column, an eight's
	column (and so on).  In fact we generalise it as below.
	</para>
	
	<table>
	  <title>Binary</title>
	  <tgroup cols="8">
	    <tbody>
	      <row>
		<entry>2<superscript>...</superscript></entry>
		<entry>2<superscript>6</superscript></entry>
		<entry>2<superscript>5</superscript></entry>
		<entry>2<superscript>4</superscript></entry>
		<entry>2<superscript>3</superscript></entry>
		<entry>2<superscript>2</superscript></entry>
		<entry>2<superscript>1</superscript></entry>
		<entry>2<superscript>0</superscript></entry>
	      </row>
	      <row>
		<entry>...</entry>
		<entry>64</entry>
		<entry>32</entry>
		<entry>16</entry>
		<entry>8</entry>
		<entry>4</entry>
		<entry>2</entry>
		<entry>1</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	
      </sect3>

      <sect3>
	<title>Bits and Bytes</title>

	<para>We call one binary digit a <emphasis>bit</emphasis>.
	Thus one bit can represent two states; on or off, true or
	false, high or low voltage.</para>

	<para>If we want to represent more than two things, we need
	more bits.  For example, to represent all the letters of the
	alphabet we would need at least enough different combinations
	to represent all the lower case letters, the upper case
	letters, numbers and punctuation, plus a few extras.  Adding
	this up means we need probably around 80 different
	combinations.</para>

	<para>If we have two bits, we can represent four possible
	unique combinations (<computeroutput>00 01 10
	11</computeroutput>).  If we have three bits, we can represent
	8 different combinations.  Thus for every
	<computeroutput>n</computeroutput> bits we can represent
	<computeroutput>2<superscript>n</superscript></computeroutput>
	unique combinations.</para>

	<para>Thus 8 bits gives us
	<computeroutput>2<superscript>8</superscript> =
	128</computeroutput> unique representations.  One less bit and
	we would only have 64 unique representations; not enough for
	our alphabet as we described above.  Thus the lowest common
	grouping of bits is in groups of 8, which we call a
	<emphasis>byte</emphasis>.  Guess how bit a C
	<computeroutput>char</computeroutput> variable is?  One
	byte.</para>

	<sect4>
	  <title>16, 32 and 64 bit computers</title>

	  <para>Numbers do not fit into bytes; hopefully your bank
	  balance in dollars will need more range than can fit into
	  one byte!  Most modern architectures are <emphasis>32
	  bit</emphasis> computers.  This means they work with 4 bytes
	  at a time when processing and reading or writing to memory.
	  We refer to 4 bytes as a <emphasis>word</emphasis>; this is
	  analogous to language where letters (bits) make up words in a
	  sentence, except in computing every word has the same size!
	  The size of a C <computeroutput>it</computeroutput>
	  variable is 32 bits.  Newer architectures are 64 bits, which
	  doubles the size the processor works with (8 bytes).</para>

	</sect4>


	<sect4>
	  <title>Kilo, Mega and Giga Bytes</title>

	  <para>Computers deal with a lot of bytes; that's what makes
	  them so powerful!</para>

	  <para>Computer scientists soon needed a way to talk about
	  these huge amounts of bytes.  A natural way was to use the
	  "International System of Units" (SI) prefixes as used in
	  most other scientific areas.  So for example, kilo refers to
	  10<superscript>3</superscript> or 1000 units, as in a
	  kilogram has 1000 grams.</para>

	  <para>1000 is a nice round number in base 10, but in binary
	  it is <computeroutput>1111101000</computeroutput> which is
	  not a particularly "round" number.  However, 1024 (or
	  2<superscript>10</superscript>) is
	  (<computeroutput>10000000000></computeroutput>), and happens
	  to be quite close to the base ten meaning of kilo (1000 as
	  opposed to 1024).</para>

	  <para>Thus 1024 bytes became known as a
	  <emphasis>kilobyte</emphasis>.  The first mass market
	  computer was the Commodore 64, so named because it
	  had 64 kilobytes of storage.</para>

	  <para>Kilobytes soon ran out however.  The next SI unit is
	  "mega" for <computeroutput>10<superscript>6</superscript>.
	  As it happens,
	  <computeroutput>2<superscript>20</superscript></computeroutput>
	  is again close to the SI base 10 definition; 1048576 as
	  opposed to 1000000.</para>

	  <para>The units keep increasing by powers of 10; each
	  time it diverges further from the base SI meaning.</para>

	  <table>
	    <title>Bytes</title>
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>2<superscript>10</superscript></entry>
		  <entry>Kilobyte</entry>
		</row>
		<row>
		  <entry>2<superscript>20</superscript></entry>
		  <entry>Megabyte</entry>
		</row>
		<row>
		  <entry>2<superscript>30</superscript></entry>
		  <entry>Gigabyte</entry>
		</row>
		<row>
		  <entry>2<superscript>40</superscript></entry>
		  <entry>Terrabyte</entry>
		</row>
		<row>
		  <entry>2<superscript>50</superscript></entry>
		  <entry>Petabyte</entry>
		</row>
		<row>
		  <entry>2<superscript>60</superscript></entry>
		  <entry>Exabyte</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Thus a 32 bit computer can address up to four
	  gigabytes of memory since the extra two bits can represent
	  four groups of
	  <computeroutput>2<superscript>30</superscript>
	  bytes.</computeroutput>.  A 64 bit computer can address up
	  to 8 exabytes; you might be interested in working out just
	  how bit a number this is!  To get a feel for how bit that
	  number is, calculate how long it would take to count to
	  <computeroutput>2<superscript>64</superscript></computeroutput>
	  if you incremented once per second.</para>

	</sect4>

	<sect4>
	  <title>Kilo, Mega and Giga Bits</title>

	  <para>Apart from the confusion related to the overloading of
	  SI units between binary and base 10 capacities will often be
	  quoted in terms of <emphasis>bits</emphasis> rather than
	  bytes.</para>

	  <para>Generally this happens when talking about networking
	  devices; you may have noticed that your ADSL connection is
	  described as something like 1500 kilobits/second.  The
	  calculation is simple; multiply by 1000 (for the kilo),
	  divide by 8 to get bytes and then 1024 to get kilobytes (so
	  1500 kilobits/s = 183 kilobytes/s).</para>

	  <para>The SI standardisation body has recognised these dual
	  uses, and has specified unique prefixes for binary usage.
	  Under the standard 1024 bytes is a
	  <computeroutput>kibibyte</computeroutput>, short for
	  <emphasis>kilo binary</emphasis> byte (shortened to KiB).
	  The other prefixes have a similar prefix (Mebibyte, for
	  example).  Tradition largely prevents use of these terms,
	  but you may seem them in some literature.</para>

	</sect4>

      </sect3>

      <sect3>
	<title>Boolean Operations</title>

	<para>George Boole was a mathematician who discovered a whole
	area of mathematics called <emphasis>Boolean
	Algebra</emphasis>.  Whilst he made his discoveries in the mid
	1800's, his mathematics are the fundamentals of all computer
	science.  Boolean algebra is a wide ranging topic, we present
	here only the bare minimum to get you started.</para>

	<para>Boolean operations simply take a particular input and
	produce a particular output following a rule.  For example,
	the simplest boolean operation,
	<computeroutput>not</computeroutput> simply inverts the value
	of the input operand.  Other operands usually take two inputs,
	and produce a single output.</para>

	<para>The fundamental Boolean operations used in computer
	science are easy to remember and listed below.  <para>We
	represent them below with <emphasis>truth tables</emphasis>;
	they simply show all possible inputs and outputs.  The term
	<emphasis>true</emphasis> simply reflects
	<computeroutput>1</computeroutput> in binary.</para>

	<sect4>
	  <title>Not</title> <para>Usually represented by
	  <computeroutput>!</computeroutput>,
	  <computeroutput>not</computeroutput> simply inverts the
	  value, so <computeroutput>0</computeroutput> becomes
	  <computeroutput>1</computeroutput> and
	  <computeroutput>1</computeroutput> becomes
	  <computeroutput>0</computeroutput></para>

	  <table>
	    <title>Truth table for <emphasis>not</emphasis></title>
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Input</entry>
		  <entry>Output</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</sect4>

	<sect4>
	  <title>And</title> <para>To remember how the and operation
	  works think of it as "if one input <emphasis>and</emphasis>
	  the other are true, result is true</para>

	  <table>
	    <title>Truth table for <emphasis>and</emphasis></title>
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Input 1</entry>
		  <entry>Input 2</entry>
		  <entry>Output</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</sect4>


	<sect4>
	  <title>Or</title>

	  <para>To remember how the
	  <computeroutput>or</computeroutput> operation works think of
	  it as "if one input <emphasis>or</emphasis> the other input
	  is true, the result is true</para>

	  <table>
	    <title>Truth table for <emphasis>or</emphasis></title>
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Input 1</entry>
		  <entry>Input 2</entry>
		  <entry>Output</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</sect4>


	<sect4>
	  <title>Exclusive Or (xor)</title>

	  <para>Exclusive or, written as
	  <computeroutput>xor</computeroutput> is a special case of
	  <computeroutput>or</computeroutput> where the output is true
	  if one, and <emphasis>only</emphasis> one, of the inputs is
	  true.  This operation can surprisingly do many interesting
	  tricks, but you will not see a lot of it in the
	  kernel.</para>

	  <table>
	    <title>Truth table for <emphasis>xor</emphasis></title>
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Input 1</entry>
		  <entry>Input 2</entry>
		  <entry>Output</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>0</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		</row>
		<row>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>1</computeroutput></entry>
		  <entry><computeroutput>0</computeroutput></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</sect4>

      </sect3>


      <sect3>
	<title>How computers use boolean operations</title>

	<para>Believe it or not, essentially everything your computer
	does comes back to the above operations.  For example, the
	half adder is a type of circuit made up from boolean
	operations that can add bits together (it is called a half
	adder because it does not handle carry bits).  Put more half
	adders together, and you will start to build something that
	can add together long binary numbers.  Add some external
	memory, and you have a computer.
	</para>

	<para>Electronically, the boolean operations are implemented
	in <emphasis>gates</emphasis> made by
	<emphasis>transistors</emphasis>.  This is why you might have
	heard about transistor counts and things like Moores Law.  The
	more transistors, the more gates, the more things you can add
	together.  To create the modern computer, there are an awful
	lot of gates, and an awful lot of transistors.  Some of the
	latest Itanium processors have around 460 million
	transistors.</para>

      </sect3>

      <sect3>
	<title>Working with binary in C</title>

	<para>In C, we can quite simply do all of the above
	operations.  The following table describes the
	operators</para>

	<table>
	  <title>Boolean operations in C</title>
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operation</entry>
		<entry>Usage in C</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><computeroutput>not</computeroutput></entry>
		<entry><computeroutput>!</computeroutput></entry>
	      </row>
	      <row>
		<entry><computeroutput>and</computeroutput></entry>
		<entry><computeroutput>&</computeroutput></entry>
	      </row>
	      <row>
		<entry><computeroutput>or</computeroutput></entry>
		<entry><computeroutput>|</computeroutput></entry>
	      </row>
	      <row>
		<entry><computeroutput>xor</computeroutput></entry>
		<entry><computeroutput>^</computeroutput></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	
	<para>We use these operations on variables to modify the bits
	within the variable.  Before we see examples of this, first we
	must understand hexadecimal notation.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>Hexadecimal</title>

      <para>Hexadecimal refers to a base 16 number system.  We use
      this in computer science for only one reason, it makes it easy
      for humans to think about binary numbers.  Computers only ever
      deal in binary, hexadecimal is simply a shortcut for us humans
      trying to work with the computer.  </para>

      <para>So why base 16?  Well, the most natural choice is base 10,
      since we are used to thinking in base 10 from our every day
      number system.  But base 10 does not work well with binary -- to
      represent 10 different elements in binary, we need four bits.
      But four bits gives us sixteen possible combinations.  So we can
      either take the very tricky road of trying to deal convert
      between base 10 and binary, or take the easy road and make up a
      base 16 number system.  This is exactly what hexadecimal
      is.</para>

      <para>Hexadecimal uses the standard base 10 numerals, but adds
      additional the additional numerals <computeroutput>A B C D E
      F</computeroutput> which refer to <computeroutput>10 11 12 13 14
      15</computeroutput> (n.b. zero is a digit like any other, so we
      can represent 16 different values).</para>

      <para>Traditionally, any time you see a number prefixed by
      <computeroutput>0x</computeroutput> this will denote a
      hexadecimal number.</para>

      <para>As mentioned, to represent 16 different patterns in
      binary, we would need exactly four bits.  Thus, each hexadecimal
      numeral represents four bits.  You should consider it an
      exercise to learn the following table off by heart.</para>

    <table>
      <title>Hexadecimal, Binary and Decimal</title>
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Hexadecimal</entry>
	    <entry>Binary</entry>
	    <entry>Decimal</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	      <entry><computeroutput>0</computeroutput></entry>
	      <entry><computeroutput>0000</computeroutput></entry>
	      <entry><computeroutput>0</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>1</computeroutput></entry>
	      <entry><computeroutput>0001</computeroutput></entry>
	      <entry><computeroutput>1</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>2</computeroutput></entry>
	      <entry><computeroutput>0010</computeroutput></entry>
	      <entry><computeroutput>2</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>3</computeroutput></entry>
	      <entry><computeroutput>0011</computeroutput></entry>
	      <entry><computeroutput>3</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>4</computeroutput></entry>
	      <entry><computeroutput>0100</computeroutput></entry>
	      <entry><computeroutput>4</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>5</computeroutput></entry>
	      <entry><computeroutput>0101</computeroutput></entry>
	      <entry><computeroutput>5</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>6</computeroutput></entry>
	      <entry><computeroutput>0110</computeroutput></entry>
	      <entry><computeroutput>6</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>7</computeroutput></entry>
	      <entry><computeroutput>0111</computeroutput></entry>
	      <entry><computeroutput>7</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>8</computeroutput></entry>
	      <entry><computeroutput>1000</computeroutput></entry>
	      <entry><computeroutput>8</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>9</computeroutput></entry>
	      <entry><computeroutput>1001</computeroutput></entry>
	      <entry><computeroutput>9</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>A</computeroutput></entry>
	      <entry><computeroutput>1010</computeroutput></entry>
	      <entry><computeroutput>10</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>B</computeroutput></entry>
	      <entry><computeroutput>1011</computeroutput></entry>
	      <entry><computeroutput>11</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>C</computeroutput></entry>
	      <entry><computeroutput>1100</computeroutput></entry>
	      <entry><computeroutput>12</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>D</computeroutput></entry>
	      <entry><computeroutput>1100</computeroutput></entry>
	      <entry><computeroutput>13</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>E</computeroutput></entry>
	      <entry><computeroutput>1101</computeroutput></entry>
	      <entry><computeroutput>14</computeroutput></entry>
	  </row>
	  <row>
	      <entry><computeroutput>F</computeroutput></entry>
	      <entry><computeroutput>1111</computeroutput></entry>
	      <entry><computeroutput>15</computeroutput></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

      <para>Of course there is no reason not to continue the pattern
      (say, assign G to the value 16), but 16 values is an excellent
      trade off between the vagaries of human memory and the number of
      bits used by a computer (occasionally you will also see base 8
      used, for example for file permissions under UNIX).  We simply
      represent larger numbers of bits with more numerals.  For
      example, a sixteen bit variable can be represented by 0xAB12,
      and to find it in binary simply take each individual numeral,
      convert it as per the table and join them all together (so
      <computeroutput>0xAB12</computeroutput> ends up as the 32 bit
      binary number
      <computeroutput>1010101100010010</computeroutput>).</para>

    </sect2>

  <sect2>
    <title>Practical Implications</title>
    <sect3>
      <title>Use of binary in code</title>

      <para>Whilst binary is the underlying language of every
      computer, it is entirely practical to program a computer in high
      level languages without knowing the first thing about it.
      However, for the low level code we are interested in a few
      fundamental binary principles are used repeatedly.</para>

    </sect3>

    <sect3>
      <title>Masking and Flags</title> 

      <sect4>
	<title>Masking</title>

	<para>In low level code, it is often important to keep your
	structures and variables as space efficient as possible.  In
	some cases, this can involve effectively packing two
	(generally related) variables into one.</para>

	<para>Remember each bit represents two states, so if we know a
	variable only has, say, 16 possible states it can be
	represented by 4 bits (i.e. 2<superscript>4</superscript> = 16
	unique values).  But the smallest type we can declare in C is
	8 bits (a <computeroutput>char</computeroutput>), so we can
	either waste four bits, or find some way to use those left
	over bits.</para>

	<para>We can easily do this by the process of
	<emphasis>masking</emphasis>.  Remembering the rules of the
	logical operations, it should become clear how the values are
	extracted.</para>

	<para>The process is illustrated in the figure below.  We are
	interested in the lower four bits, so set our mask to have
	these bits set to <computeroutput>1</computeroutput>.  Since
	the <computeroutput>logical and</computeroutput> operation
	will only set the bit if <emphasis>both</emphasis> bits are
	<computeroutput>1</computeroutput>, those bits of the mask set
	to <computeroutput>0</computeroutput> effectively hide the bits
	we are not interested in.</para>

	  <figure>
	    <title>Masking</title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="wk1/figures/masking.eps" format="EPS">
	      </imageobject>
	      <imageobject>
		<imagedata fileref="wk1/figures/masking.png" format="PNG">
	      </imageobject>
	      <textobject>

		<phrase>By using a <emphasis>mask</emphasis> consisting
	      of all <computeroutput>1</computeroutput>'s and the
	      <computeroutput>logical and</computeroutput> operation,
	      we can extract only the bits we are interested
	      in.</phrase>
		
	      </textobject>
	    </mediaobject>
	  </figure>

	<para>To get the top (blue) four bits, we would invert the
	mask.  You will note this gives a result of
	<computeroutput>0x90</computeroutput> when really we want a
	value of <computeroutput>0x09</computeroutput>.  To get the
	bits into the right position we use the <computeroutput>right
	shift</computeroutput> operation.</para>

	<para><emphasis>Setting</emphasis> the bits requires the
	<computeroutput>logical or</computeroutput> operation.
	However, rather than using
	<computeroutput>1</computeroutput>'s as the mask, we use
	<computeroutput>0</computeroutput>'s.  You should draw a
	diagram similar to the above figure and work through setting
	bits with the <computeroutput>logical
	or</computeroutput> operation.</para>

      </sect4>

      <sect4>
	<title>Flags</title>

	<para>Often a program will have a large number of variables
	that only exist as <emphasis>flags</emphasis> to some
	condition.  For example, a state machine is an algorithm that
	transitions through a number of different states but may only
	be in one at a time.  Say it has 8 different states; we could
	easily declare 8 different variables, one for each state.  But
	in many cases it is better to declare <emphasis>one 8 bit
	variable</emphasis> and assign each bit to
	<emphasis>flag</emphasis> flag a particular state.</para>

	<para>Flags are a special case of masking, but each bit
	represents a particular boolean state (on or off).  Thus an
	<emphasis>n</emphasis> bit variable can hold
	<emphasis>n</emphasis> different flags.  See the code example
	below for a typical example of using flags -- you will see
	variations on this basic code very often.
	</para>

	<example id="flag-code">
	  <title>Using flags</title>
	  <programlisting linenumbering="numbered" lang="C"><inlinemediaobject>
	      <imageobject>
		<imagedata fileref="wk1/code/flags.c" format="linespecific">
	      </imageobject>
	    </inlinemediaobject></programlisting>
	</example>    

	</sect4>
	
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Types and Number Representation</title>

    <sect2>
      <title>C Standards</title>

      <para>Although a slight divergence, it is important to
      understand a bit of history about the C language.</para>

      <para>C is the <emphasis>lingua franca</emphasis> of the systems
      programming world.  Every operating system and its associated
      system libraries in common use is written in C.  Every system
      provides a C compiler.</para>

      <para>To stop the language diverging across each systems making
      and numerous incompatible changes a strict standard has been
      written for the language.</para>

      <para>Officially this standard is known as ISO/IEC 9899:1999(E),
      but is more commonly referred to by its shortened version C99.
      The standard is maintained by the International Standards
      Organisation (ISO) and the full standard is available for
      purchase online.  Older standards versions such as C89 (the
      predecesor to C99 released in 1989) and ANSI C are no longer in
      common usage.</para>

      <para>The standard documenation is very technical, and details
      every part of the language.  For example it explains the syntax,
      standard <computeroutput>#define</computeroutput> values and how
      operations should behave.</para>

      <sect3>
	<title>GNU C</title>

	<para>The GNU C Compiler, more commonly referred to as
	<application>gcc</application>, almost completely implements
	the C99 standard.  However it also implements a range of
	extensions to the standard which programmers will often use to
	gain extra functionality, at the expense of portability to
	another compiler.  These extensions are usually related to
	very low level code and are much more common in the system
	programming field.  You should however read the
	<application>gcc</application> documenation and understand
	when you may be using parts that diverge from the
	standards.</para>

	<para><application>gcc</application> can be directed to stick
	strictly to the standard (the
	<computeroutput>-std=c99</computeroutput> flag for example)
	and warn or create an error when certain things are done that
	are not in the standard.  This is obviously appropriate if you
	need to ensure that you can move your code easily to another
	compiler.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>Types</title>

      <para>As you will know, in C every variable must be declared
      with a <emphasis>type</emphasis>.  Every variable is really just
      a small section of memory, so the type is really just a
      directive to the compiler about how <emphasis>much</emphasis>
      memory to put aside for the variable.</para>

      <para>The C99 standard purposely only mentions the
      <emphasis>smallest</emphasis> possible size of each of the types
      defined for C.  This is because across different processor
      architectures and operating systems the best size for
      types can be wildley different.</para>

      <para>To be completey safe programmers need to never assume the
      size of any of their variables.  However a functioning system
      obviously needs agreements on what sizes types are going to be
      used in the system.  Thus each architecture and operating system
      conforms to an <emphasis>Application Binary Interface</emphasis>
      or <emphasis>ABI</emphasis>.  The ABI for a system fills in the
      details between the C standard and the requirements of the
      underlying hardware and operating system.  An ABI is written for
      a specific processor and operating system combination.</para>

      <table>
	<title>Standard Integer Types and Sizes</title>

	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Type</entry>
	      <entry>C99 minimum size (bits)</entry>
	      <entry>Common size (32 bit architecture)</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><computeroutput>char</computeroutput></entry>
	      <entry>8</entry>
	      <entry>8</entry>
	    </row>
	    <row>
	      <entry><computeroutput>short</computeroutput></entry>
	      <entry>16</entry>
	      <entry>16</entry>
	    </row>
	    <row>
	      <entry><computeroutput>int</computeroutput></entry>
	      <entry>16</entry>
	      <entry>32</entry>
	    </row>
	    <row>
	      <entry><computeroutput>long</computeroutput></entry>
	      <entry>32</entry>
	      <entry>32</entry>
	    </row>
	    <row>
	      <entry><computeroutput>long long</computeroutput></entry>
	      <entry>64</entry>
	      <entry>64</entry>
	    </row>
	    <row>
	      <entry>Pointers</entry>
	      <entry>Implemenation dependent</entry>
	      <entry>32</entry>
	    </row>
	  </tbody>
	</tgroup>

      </table>

      <para>Above we can see the only divergence from the standard is
      that <computeroutput>int</computeroutput> is commonly a 32 bit
      quantity, which is twice the minimum size C99 requires.</para>

      <para>Pointers are really just an address (i.e. their value is
      an address and thus "points" somewhere else in memory).  Thus a
      pointer needs to be sufficient in size to be able to address any
      memory in the system.</para>

      <sect3>
	<title>64 bit</title>

	<para>One area that causes confusion is the introduction of 64
	bit computing.  This means that the processor can handle
	addresses 64 bits in length (specifically the registers are 64
	bits wide; a topic we discuss in the next week).</para>

	<para>This firstly means that all pointers are required to be
	a 64 bits wide so that it can represent any possible address
	in the system.</para>

	<para>However, there are decisions to be made for implementors
	about the size of the other types.  Two common models are
	widely used, as shown below.</para>

	<table>
	  <title>Standard Scalar Types and Sizes</title>

	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry>Type</entry>
		<entry>C99 minimum size (bits)</entry>
		<entry>Common size (LP64)</entry>
		<entry>Common size (Windows)</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><computeroutput>char</computeroutput></entry>
		<entry>8</entry>
		<entry>8</entry>
		<entry>8</entry>
	      </row>
	      <row>
		<entry><computeroutput>short</computeroutput></entry>
		<entry>16</entry>
		<entry>16</entry>
		<entry>16</entry>
	      </row>
	      <row>
		<entry><computeroutput>int</computeroutput></entry>
		<entry>16</entry>
		<entry>32</entry>
		<entry>32</entry>
	      </row>
	      <row>
		<entry><computeroutput>long</computeroutput></entry>
		<entry>32</entry>
		<entry>64</entry>
		<entry>32</entry>
	      </row>
	      <row>
		<entry><computeroutput>long long</computeroutput></entry>
		<entry>64</entry>
		<entry>64</entry>
		<entry>64</entry>
	      </row>
	      <row>
		<entry>Pointers</entry>
		<entry>Implemenation dependent</entry>
		<entry>64</entry>
		<entry>64</entry>
	      </row>
	    </tbody>
	  </tgroup>

	</table>

	<para>You can see that in the LP64 (long-pointer 64) model
	<computeroutput>long</computeroutput> values are defined to be
	64 bits wide.  This is different to the 32 bit model we showed
	previously.  The LP64 model is widely used on UNIX
	systems.</para>

	<para>In the other model,
	<computeroutput>long</computeroutput> remains a 32 bit value.
	This maintains maximum compatability with 32 code.  This model
	is in use with 64 bit Windows.</para>

	<para>There are good reasons why the size of
	<computeroutput>int</computeroutput> was not increased to 64
	bits in either model.  Consider that if the size of
	<computeroutput>int</computeroutput> is increased to 64 bits
	you leave programmers no way to obtain a 32 bit variable.  The
	only possibly is redefining
	<computeroutput>shorts</computeroutput> to be a larger 32 bit
	type.</para>

	<para>A 64 bit variable is so large that it is not generally
	required to represent many variables.  Loops for example very
	rarely repeat more times than would fit in a 32 bit variable
	(4294967296 times!).  Images usually are usually represented
	with 8 bits for each of a red, green and blue value and an
	extra 8 bits for extra (alpha channel) information; a total of
	32 bits.  In the majority of cases, using a 64 bit variable
	will be wasting the top 32 bits.  Not only this, but the size
	of an integer array has now doubled too.  This means the size
	of programs is bigger; they take up more memory and thus more
	cache memory (discussed in detail next week) for no real
	improvement.  For the same reason Windows elected to keep
	their long values as 32 bits; since much of the Windows API
	was originally written to use long variables on a 32 bit
	system and hence does not require the extra bits this saves
	considerable wasted space in the system without having to
	re-write all the API.</para>

	<para>So consider our proposed alternative where
	<computeroutput>short</computeroutput> was redefined to be a
	32 bit variable; programmers working on a 64 bit system could
	use it for variables they know are bounded to smaller values.
	However, when moving back to a 32 bit system their same
	<computeroutput>short</computeroutput> variable would now be
	only 16 bits long, a value which is much more realistically
	overflowed.</para>

	<para>Thus by making a programmer request larger variables
	when they know they will be needed strikes a balance with
	respect to portability concerns and wasting space in
	binaries.</para>

      </sect3>

      <sect3>
	<title>Type qualifiers</title>

	<para>The C standard also talks about some qualifiers for
	variable types.  For example
	<computeroutput>const</computeroutput> means that a variable
	will never be modified from its original value and
	<computeroutput>volatile</computeroutput> suggests to the
	compiler that this value might change without you realising it
	so it can not try to be smart and re-order access to it in any
	way.</para>

	<para><computeroutput>signed</computeroutput> and
	<computeroutput>unsigned</computeroutput> are probably the two
	most important qualifiers; and they say if a variable can take
	on a negative value or not.  We examine this in more detail
	below.</para>

	<para>These qualifiers are all intended to pass extra
	information about how the variable will be used to the
	compiler.  This means two things; the compiler can check if
	you are violating your own rules (e.g. writing to a
	<computeroutput>const</computeroutput> value) and it can make
	optimisations based upon the extra knowledge (exaimined in
	later weeks).</para>

      </sect3>

      <sect3>
	<title>Standard Types</title>

	<para>C99 realises that all these rules can become very
	confusing very quickly.  Thus it provides a series of special
	types which can specify the exact properties of a variable.
	These are defined in
	<computeroutput>&lt;stdint.h&gt;</computeroutput> and have the
	form <computeroutput>qtypes_t</computeroutput> where
	<computeroutput>q</computeroutput> is a qualifier,
	<computeroutput>type</computeroutput> is the base type,
	<computeroutput>s</computeroutput> is the width in bits and
	<computeroutput>_t</computeroutput> is an extension so
	you know you are using the C99 defined types.</para>

	<para>So for example <computeroutput>uint8_t</computeroutput>
	is an unsigned integer exactly 8 bits wide.  Many other types
	are defined; the complete list is detailed in C99 17.8 or
	(more cryptically) in the header file. <footnote><para>Note
	that C99 also has portability helpers for
	<computeroutput>printf</computeroutput>.  The
	<computeroutput>PRI</computeroutput> macros in
	<computeroutput>&lt;inttypes.h&gt;</computeroutput> can be
	used as specifiers for types of specified sizes.  Again see
	the standard or pull apart the headers for full
	information.</para></footnote></para>

	<para>It is up to the system implementing the C99 standard to
	provide these types for you by mapping them to appropriate
	sized types on the target system; on Linux these headers are
	provided by the system libraries.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>Number Representation</title>


      <sect3>
	<title>Negative Values</title>

	<para>Negative Values</para>

	<sect4>
	  <title>Sign Bit</title>
	  <para>single big</para>
	</sect4>

	<sect4>
	  <title>One's Complement</title>
	  <para>ones</para>
	</sect4>

	<sect4>
	  <title>Two's Compelement</title>
	  <para>twos</para>
	</sect4>

      </sect3>

      <sect3>
	<title>Floating Point</title>
	<para>Very short intro to floating point</para>
      </sect3>

    </sect2>

  </sect1>

  <sect1>
    <title>Exercises</title>
      <itemizedlist>
	<listitem>
	  <para>Write all 16 hexadecimal digits in binary, from memory.</para>
	<listitem>
	<para>Use the <computeroutput>sizeof</computeroutput> operator
	in C to find and print the size of ...</para>
	</listitem>
	<listitem>
	  <para>It is possible to use the XOR operation to swap two
	  variables without requiring an temporary variable.  Play
	  around with it, and see if you can figure out
	  how.</para>
	</listitem>
  </sect1>

</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.sgml" "book" "chapter")
End:
-->