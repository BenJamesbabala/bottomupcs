<chapter id="wk7">

  <title>ELF</title>

  <sect1>
    <title>Review of executable files</title>

    <para>We know that a program running in memory has two major
    components in <emphasis>code</emphasis> and
    <emphasis>data</emphasis>. However, an executable does not live
    its life in memory, but spends most of its life as a file on a
    disk.  This file is in what is referred to as a binary format,
    since the bits and bytes of the file are to be interpreted
    directly by processor hardware.</para>

    <para>The executable is created by the compiler from the source
    code.  This file needs to be in a format explicitly defined such
    that the compiler can create it and the operating system can
    identify it and load into memory.  This <emphasis>executable file
    format</emphasis> can be specific to the operating system, as we
    would not normally expect that a program compiled for one system
    will execute on another (for example, you don't expect your
    Windows programs to run on Linux, or you Linux programs to run on
    OS X).</para>

    <para>However, the common thread between all exectuable file
    formats is that they include a predefined, standardised header
    which describes how program code and data are stored in the rest
    of the file.  In words, it would generally describe "the program
    code starts 20 bytes into this file, and is 50 kilobytes long.
    The program data follows it and is 20 kilobytes long".</para>

    <para>In recent times one particular format has become
      the defacto standard for executable representation for modern
      UNIX type systems.  It is called the <computeroutput>Executable
      and Linker Format</computeroutput>, or ELF for short.</para>

  </sect1>

  <sect1>
    <title>Representing executable files</title>

    <sect2>
      <title>Three Standard Sections</title>

      <para>Any executable file format will need to specify where the
      code and data are in the binary file.</para>

      <para>One additional component we have not mentioned until now
      is storage space of uninitalised global variables.  If we
      declare a variable and give it an inital value this obviously
      needs to be stored in the executable file so that upon execution
      the value is correct.  However many variables are uninitalised
      (or zero) when the program is first executed.  Making space for
      these in the executable and then simply storing zero or NULL
      values in it is a waste of space, needlessly bloating the
      executable file size.  Thus each exectuable file can define a
      BSS section which simply gives a size for the uninitalised data;
      on program load the extra memory can be allocated (and set to
      zero!).<footnote> <para>BSS probably stands for Block Started by
      Symbol, an assembly command for a old IBM
      computer.</para></footnote></para>
    </sect2>

    <sect2>
      <title>Binary Format History</title>

      <sect3>
	<title>a.out</title>

	<para>ELF was not always the standard; original UNIX systems
      used a file format called
      <computeroutput>a.out</computeroutput>.  We can see the
      vestiages of this if you compile a program without the
      <option>-o</option> option to specify an output file name; the
      executable will be created with a default name of
      <computeroutput>a.out</computeroutput><footnote> <para>In fact,
      <computeroutput>a.out</computeroutput> is the default output
      filename from the <emphasis>linker</emphasis>.  The compiler
      generally uses randomly generated file names as intermediate
      files for assembly and object code.</para></footnote>.</para>

	<para><computeroutput>a.out</computeroutput> is a very simple
	header format that only allows a single data, code and bss
	section.  As you will come to see, this is insufficient for
	modern systems with dynamic libraries.</para>

      </sect3>

      <sect3>
	<title>COFF</title>

	<para>The Common Object File Format, or COFF, was the
	precursor to ELF.  It's header format was more flexible,
	allowing an more (but limited) sections in the file.</para>

	<para>COFF also has difficulties with elegant support of
	shared libraries, and ELF was selected as an alternative
	implementation on Linux.</para>

	<para>However, COFF lives on in Microsoft Windows as the
	<computeroutput>Portable Executable</computeroutput> or PE
	format.  PE is to Windows as ELF is to Linux.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>ELF</title>

      <para>ELF is an extremely flexible format for representing binary
    code in a system.  By following the ELF standard you can represent
    a kernel binary just as easily as a normal executable or a system
    library.  The same tools can be used to inspect and operate on all
    ELF files amd developers who understand the ELF file format can
    translate their skills to most modern UNIX systems.</para>
    </sect2>

  </sect1>

  <sect1>
    <title>ELF in depth</title>

    <sect2>
      <title>Overview</title>

      <para>ELF extends on COFF and gives the header sufficient
    flexability to define an arbitrary number of sections, each with
    it's own properties.  This facilitates easier dynamic linking and
    debugging (XXX need more talk of debug).</para>
      
      <figure>
	<title>ELF Overview</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="wk7/figures/elf-overview.eps" format="EPS">
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="wk7/figures/elf-overview.png" format="PNG">
	  </imageobject>
	  <textobject>
	    <phrase>ELF Overview</phrase>
	  </textobject>
	</mediaobject>
      </figure>
    </sect2>
    
    <sect2>
      <title>ELF File Header</title>

      <para>Overall, the file has a <emphasis>file header</emphasis>
    which describes the file in general and then has pointers to each
    of the individual sections that make up the file.</para>
      
      <example id="elf-header">
	<title>The ELF Header</title>
	<programlisting linenumbering="numbered"><inlinemediaobject>
	    <imageobject>
	      <imagedata fileref="wk7/code/elf-header.txt" format="linespecific">
	    </imageobject>
	  </inlinemediaobject></programlisting>
      </example>    
      
      <para>The relevant standards document describes each field in
    detail, but there are some points to note from looking at the
    definition of the header.</para>

      <itemizedlist>
	<listitem>
	  <para>ELF defines both 32 and 64 bit versions; here we
	  inspect the 32 bit version.</para> 
	</listitem>

	<listitem>
	  <para>The <computeroutput>e_ident</computeroutput> array
	  always starts with a few "magic" bytes.  The first byte is
	  0x7F and then the next three bytes are "ELF".  You can
	  inspect an ELF binary to see this for yourself with
	  something like the <command>hexdump</command> command.
	  </para>

	  <example id="elf-magic">
	    <title>Inspecting the ELF magic number</title>
	    <programlisting><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="wk7/code/elf-magic.txt" format="linespecific">
		</imageobject>
	      </inlinemediaobject></programlisting>
	  </example>    

	  <para>Note the 0x7F to start, then the ASCII encoded "ELF"
	  string".  Have a look at the standard and see what the rest
	  of the array defines and what the values are in a
	  binary.</para>

	</listitem>



      </itemizedlist>
    </sect2>
  </sect1>

  <sect1>
    <title>Sections and Segments</title>

    <para>The ELF format specifies two "views" of an ELF file -- that
    which is used for linking and that which is used for
    execution.  This affords </para>

    <para>Thus the </para>

  </sect1>

</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.sgml" "book" "chapter")
End:
-->