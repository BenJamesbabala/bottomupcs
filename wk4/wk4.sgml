<chapter id="wk4">
  
  <title>The Process</title>

  <sect1>
    <title>What is a process?</title>

    <para>We are all familiar with the modern operating system running
    many tasks all at once or <emphasis>multitasking</emphasis>.  
    </para>

    <para>We can think of each process as a bundle of elements kept by
    the kernel to keep track of all these running tasks.</para>

  </sect1>

  <sect1>
    <title>Elements of a process</title>

    <figure>
      <title>The Elements of a Process</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="wk4/figures/theprocess.eps" format="EPS">
	</imageobject>
	<imageobject>
	  <imagedata fileref="wk4/figures/theprocess.png" format="PNG">
	</imageobject>
	<textobject>
	  <phrase>The essential elements of a process; the process ID,
	  memory, files and registers.</phrase>
	</textobject>
      </mediaobject>
    </figure>

    <sect2>
      <title>Process ID</title>

      <para>The <emphasis>process ID</emphasis> (or the PID) is
      assigned by the operating system and is unique to each running
      process.</para>

    </sect2>

    <sect2>
      <title>Memory</title> <para>We will learn exactly how a process
      gets it's memory in the following weeks -- it is one of the most
      fundamental parts of how the operating system works.  However,
      for now it is sufficient to know that each process gets it's own
      section of memory.</para>

      <para>In this memory all the program code is stored, along with
      variables and any other allocated storage.</para>

      <para>Parts of the memory can be shared between process (called,
      not surprisingly <emphasis>shared memory</emphasis>).  You will
      often see this called <emphasis>System Five Shared
      Memory</emphasis> (or SysV SHM) after the original
      implementation in an older operating system.</para>

      <para>Another important concept a process may utilise is that of
      <emphasis>mmap</emphasis>ing a file on disk to memory.  This
      means that instead of having to open the file and use commands
      such as <computeroutput>read()</computeroutput> and
      <computeroutput>write()</computeroutput> the file looks as if it
      were any other type of
      RAM. <computeroutput>mmaped</computeroutput> areas have
      permissions such as read, write and execute which need to be
      kept track of.  As we know, it is the job of the operating
      system to maintain security and stabilitiy, so it needs to check
      if a process tries to write to a read only area and return an
      error.</para>

    </sect2>

    <sect2>
      <title>File Descriptors</title> 
      <para>In the first week we learnt about
      <computeroutput>stdin</computeroutput>,
      <computeroutput>stdout</computeroutput> and
      <computeroutput>stderr</computeroutput>; the default files given
      to each process.  You will remember that these files always have
      the same file descriptor number (0,1,2 respectively).</para>

      <para>Thus, file descriptors are kept by the kernel individually
      for each process.</para>

      <para>File descriptors also have permissions.  For example, you
      may be able to read from a file but not write to it.  When the
      file is opened, the operating system keeps a record of the
      processes permissions to that file in the file descriptor and
      doesn't allow the process to do anything it shouldn't.</para>
    </sect2>

    <sect2>
      <title>Registers</title>

      <para>We know from the previous chapter that the processor
      esentially performs generally simple operations on values in
      registers.  These values are read (and written) to memory -- we
      mentioned above that each process is allocated memory which the
      kernel keeps track of.</para>

      <para>So the other side of the equation is keeping track of the
      registers.  When it comes time for the currently running process
      to give up the processor so another process can run, it needs to
      save it's current state.  Equally, we need to be able to restore
      this state when the process is given more time to run on the
      CPU.  To do this the operating system needs to store a copy of
      the CPU registers to memory.  When it is time for the process to
      run again, the operating system will copy the register values
      back from memory to the CPU registers and the process will be
      right back where it left off.
      </para>
    </sect2>

    <sect2>
      <title>Kernel State</title>

      <para>Internally, the kernel needs to keep track of a number of
      elements for each process.</para>

      <sect3>
	<title>Process State</title>

	<para>Another important element for the operating system to keep
      track of is the process state.  If the process is currently
      running it makes sense to have it in a
      <emphasis>running</emphasis> state.</para>

	<para>However, if the process has requested to read a file from
      disk we know from our memory hierarchy that this may take a
      significant amount of time.  The process should give up it's
      current execution to allow another process to run, but the
      kernel need not let the process run again until the data from
      the disk is available in memory.  Thus it can mark the process
      as <emphasis>disk wait</emphasis> (or similar) until the data is
      ready.</para>

      </sect3>

      <sect3>
	<title>Priority</title> 
	<para>Some processes are more important than others, and get a higher
	priority.  See the discussion on the scheduler below.</para>
      </sect3>

      <sect3>
	<title>Statistics</title>
	<para>The kernel can keep statistics on each processes
	behaviour which can help it make decisions about how the
	process behaves; for example does it mostly read from disk or
	does it mostly do CPU intensive operations?</para>
      </sect3>

    </sect2>

  </sect1>

  <sect1>
    <title>Process Hierarchy</title>
 
    <para>Whilst the operating system can run many processes at the
    same time, in fact it only ever directly starts one process called
    the <emphasis>init</emphasis> (short for inital) process.  This
    isn't a particularly special process except that it's PID is
    always 0 and it will <emphasis>always</emphasis> be
    running.</para>

    <para>All other processes can be considered
    <emphasis>children</emphasis> of this inital process.  Processes
    have a family tree just like any other; each process has a
    <emphasis>parent</emphasis> and can have many
    <emphasis>siblings</emphasis>, which are processes
    created<footnote> <para>The term <emphasis>spawn</emphasis> is
    often used when talking about parent processes creating children;
    as in "the process spawned a child".</para></footnote> by the same
    parent.</para>

    <para>Certainly children can create more children and so on and so
    forth.</para>

    <example id="pstree">
      <title><command>pstree</command> example</title>
      <programlisting><inlinemediaobject>
	  <imageobject>
	    <imagedata fileref="wk4/code/pstree.txt" format="linespecific">
	  </imageobject>
	</inlinemediaobject></programlisting>
    </example>    

  </sect1>


  <sect1>
    <title>Fork and Exec</title>

    <para></para>

    <sect2>
      <title>Fork</title>
      <para>fork</para>
    </sect2>

    <sect2>
      <title>Exec</title>
      <para></para>
    </sect2>

    <sect2>
      <title>The <application>init</application> process</title>

      <para></para>

    </sect2>
  </sect1>

  <sect1>
    <title>Context Switching</title>
    <para></para>
  </sect1>

  <sect1>
    <title>Scheduling</title>
    <para></para>

    <sect2>
      <title>Hard v Soft Realtime</title>
      <para></para>
    </sect2>

  </sect1>

</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.sgml" "book" "chapter")
End:
-->