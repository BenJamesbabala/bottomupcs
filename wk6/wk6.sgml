<chapter id="wk6">
  
  <title>The Toolchain</title>

  <sect1>
    <title>Compiled v Interpreted Programs</title>

    <sect2>
      <title>Compiled Programs</title>

      <para>So far we have discussed how a program is loaded into
    virtual memory, started as a process kept track of by the
    operating system and interacts with via system calls.</para>
      
      <para>A program that can be loaded directly into memory needs to
    be in a straight <emphasis>binary</emphasis> format.  The process
    of converting source code, written in a language such as C, to a
    binary file ready to be executed is called
    <emphasis>compiling</emphasis>.  Not surprisingly, the process is
    done by a <emphasis>compiler</emphasis>; the most widespread
    example being <productname>gcc</productname>.
    </para>

    </sect2>

    <sect2>
      <title>Interpreted programs</title>

      <para>Compiled programs have some disadvantages for modern
      software development.  Every time a developer makes a change,
      the compiler must be invoked to recreate the executable file.
      It is a logical extension to design a compiled program that can
      read <emphasis>another</emphasis> program listing and execute
      the code line by line.
      </para>

      <para>We call this type of compiled program a
      <emphasis>interpreter</emphasis> because it interprets each line
      of the input file and executes it as code.  This way the program
      does does not need to be compiled, and any changes will be seen
      the next time the interpreter runs the code.</para>

      <para>For their convenience, interpreted programs usually run
      slower than a compiled counterpart.  The overhead in the program
      reading and interpreting the code each time is only encountered
      once for a compiled program, whilst an interpreted program
      encounters it each time it is run.</para>

      <para>But interpreted languages have many positive aspects.
      Many interpreted languages actually run in a
      <computeroutput>virtual machine</computeroutput> that is
      abstracted from the underlying hardware.  Python and Perl 6 are
      languages that implement a virtual machine that interpreted code
      runs on.</para>

      <sect3>
	<title>Virtual Machines</title>
	
	<para>A compiled program is completely dependent on the
	hardware of the machine it is compiled for, since it must be
	able to simply be copied to memory an executed.  A virtual
	machine is an abstraction of hardware into software.</para>

	<para>For example, Java is a hybrid language that is partly
      compiled and partly interpreted.  Java code is complied into a
      program that runs inside a <emphasis>Java Virtual
      Machine</emphasis> or more commonly referred to as a JVM.  This
      means that a compiled program can run on any hardware that has a
      JVM written for it; so called <emphasis>write one, run
      anywhere</emphasis>.</para>

      </sect3>


    </sect2>

  </sect1>

  <sect1>
    <title>Building an executable</title>

    <para>When we talk about the compiler, there are actually three
    separate steps involved in creating the executable file.</para>

    <orderedlist>
      <listitem>
	<para>Compiling</para>
      </listitem>
      <listitem>
	<para>Assembling</para>
      </listitem>
      <listitem>
	<para>Linking</para>
      </listitem>
    </orderedlist>

    <para>The components involved in this process are collectively
    called the <emphasis>toolchain</emphasis> because the tools
    <emphasis>chain</emphasis> the output of one to the input of the
    other to create the final output.</para>

    <para>Each link in the chain takes the source code progressively
    closer to being binary code suitable for execution.</para>

  </sect1>

  <sect1>
    <title>Compiling</title>

    <sect2>
      <title>The process of compiling</title>

    <para>The first step of compiling a source file to an executable
    file is converting the code from the high level, human
    understandable language to <emphasis>assembly code</emphasis>.  We
    know from previous chapters than assembly code works directly with
    the instructions and registers provided by the processor.</para>

    <para>The compiler is the most complex step of process for a
    number of reasons.  Firstly, humans are very unpredictable and
    have their source code in many different forms.  The compiler is
    only interested the actual code, however humans need things like
    comments and whitespace (spaces, tabs, indents, etc) to understand
    code.  The process that the compiler takes to convert the
    human-written source code to its internal representation is called
    <emphasis>parsing</emphasis>.</para>

      <sect3>
	<title>C code</title>

	<para>With C code, there is actually a step
	<emphasis>before</emphasis> parsing the source code called the
	<emphasis>pre-processor</emphasis>.  The pre-processor is at
	its core a text replacement program.  For example, any
	variable declared as <computeroutput>#define variable
	text</computeroutput> will have
	<computeroutput>variable</computeroutput> replaced with
	<computeroutput>text</computeroutput>.  This preprocessed code
	is then passed into the compiler.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>Syntax</title>
      
      <para>Any computing language has a particular
      <emphasis>syntax</emphasis> that describes the rules of the
      language.  Both you and the compiler know the syntax rules, and
      all going well you will understand each other.  Humans, being as
      they are, often forget the rules or break them, leading the
      compiler to be unable to understand your intentions.  For
      example, if you were to leave the closing bracket off a
      <computeroutput>if</computeroutput> condition, the compiler does
      not know where the actual conditional is.</para>

      <para>Syntax is most often described in <emphasis>Backus-Naur
      Form</emphasis> (BNF)<footnote><para>In fact the most common
      form is Extended Backus-Naur Form, or EBNF, as it allows some
      extra rules which are more suitable for modern
      languages.</para></footnote> which is a language with which you
      can describe languages!</para>

    </sect2>

    <sect2>
      <title>Optimisation</title> 

      <para>Once the compiler has an internal representation of the
      code, the <emphasis>really</emphasis> interesting part of the
      compiler starts.  The compiler wants to find the most optimised
      assembly language output for the given input code.  This is a
      large and varied problem and requires knowledge of everything
      from efficient algorithms based in computer science to deep
      knowledge about the particular processor the code is to be run
      on.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Assembler</title>

    <para>The assembly code outputted by the compiler is still in a
    human readable form, should you know the specifics of the assembly
    code for the processor.  Developers will often take a peek at the
    assembly output to manually check that the code is the most
    optimised or to discover any bugs in the compiler (this is more
    common than one might think, especially when the compiler is
    being very aggressive with optimisations).</para>

    <para>The assembler is a more mechanical process of converting the
    assembly code into a binary form.  Essentially, the assembler
    keeps a large table of each possible instruction and its binary
    counterpart (called an <emphasis>op code</emphasis> for operation
    code).  It combines these opcodes with the registers specified in
    the assembly to produce a binary output file.</para>

    <para>This code is called <emphasis>object code</emphasis> and, at
    this stage, is not executable.  Object code is simply a binary
    representation of specific input source code file.  Good
    programming practice dictates that a programmer should not "put
    all the eggs in one basket" by placing all your source code in one
    file.</para>

  </sect1>

  <sect1>
    <title>Linker</title>

    <para>Often in a large program, you will separate out code into
      multiple files to keep related functions together.  Each of
      these files can be compiled into object code: but your final
      goal is to create a single executable! There needs to be some
      way combining each of these object files into a single
      executable.  We call this linking.</para>

    <para>Note that even if your program does fit in one file it still
    needs to be linked against certain system libraries to operate
    correctly.  For example, the
    <computeroutput>printf</computeroutput> call is kept in a library
    which must be combined with your executable to work.  So although
    you do not explicilty have to worry about linking in this case,
    there is most certainly still a linking process happening to
    create your executable.</para>

    <para>In the following sections we explain some terms essential to
    understanding linking.</para>

    <sect2>
      <title>Symbols</title>

      <sect3>
      <title>Symbols</title>

      <para>Variables and functions all have names in source code
      which we refer to them by.  One way of thinking of a statement
      declaring a variable <computeroutput>int a</computeroutput> is
      that you are telling the compiler "set aside some memory of
      <computeroutput>sizeof(int)</computeroutput> and from now on
      when I use <computeroutput>a</computeroutput> it will refer to
      this allocated memory.  Similarly a function says "store this
      code in memory, and when I call
      <computeroutput>function()</computeroutput> jump to and execute
      this code".
      </para>

      <para>In this case, we call <computeroutput>a</computeroutput>
      and <computeroutput>function</computeroutput>
      <emphasis>symbols</emphasis> since they are a symbolic
      representation of an area of memory.</para>

      <para>Symbols help humans to understand programming.  You could
      say that the primary job of the compilation process is to remove
      symbols -- the processor doesn't know what
      <computeroutput>a</computeroutput> represents, all it knows is
      that it has some data at a particular memory address.  The
      compilation process needs to convert <computeroutput>a +=
      2</computeroutput> to something like "increment the value in
      memory at <computeroutput>0xABCDE</computeroutput> by 2.</para>
    </sect3>

      <sect3>
	<title>Symbol Visibility</title>

	<para>In some C programs, you may have seen the terms
      <computeroutput>static</computeroutput> and
      <computeroutput>extern</computeroutput> used with variables.
      These modifiers can effect what we call the visibility of
      symbols.</para>

	<para>Imagine you have split up your program in two files, but
      some functions need to share a variable.  You only want one
      <emphasis>definition</emphasis> (i.e. memory location) of the
      shared variable (otherwise it wouldn't be shared!), but both
      files need to reference it.</para>
	
	<para>To enable this, we declare the variable in one file, and
      then in the other file declare a variable of the same name but
      with the prefix <computeroutput>extern</computeroutput>.
      <computeroutput>extern</computeroutput> stands for
      <emphasis>external</emphasis> and to a human means that this
      variable is declared somewhere else.</para>
	
	<para>What <computeroutput>extern</computeroutput> says to a
      compiler is that it should not allocate any space in memory for
      this variable, and leave this symbol in the object code where it
      will be fixed up later.  The compiler can not possibly know
      where the symbol is actually defined but the
      <emphasis>linker</emphasis>does, since it is it's job to look at
      all object files together and combine them into a single
      executable.  So the linker will see the symbol left over in the
      second file, and say "I've seen that symbol before in file 1,
      and I know that it refers to memory location
      <computeroutput>0x12345</computeroutput>".  Thus it can modify
      the symbol value to be the memory value of the variable in the
      first file.</para>
	
	<para><computeroutput>static</computeroutput> is almost the
      opposite of <computeroutput>extern</computeroutput>.  It places
      restrictions on the visiblity of the symbol it modifies.  If you
      declare a variable with <computeroutput>static</computeroutput>
      that says to the compiler "don't leave any symbols for this in
      the object code".  This means that when the linker is linking
      together object files it will never see that symbol (and so
      can't make that "I've seen this before!" connection).
      <computeroutput>static</computeroutput> is good for separation
      and reducing conflicts -- by declaring a variable
      <computeroutput>static</computeroutput> you can reuse the
      variable name in other files and not end up with symbol clashes.
      We say we are <emphasis>restricting the visiblity</emphasis> of
      the symbol, because we are not allowing the linker to see it.
      Contrast this with a more visible symbol (one not declared with
      <computeroutput>static</computeroutput>) which can be seen by
      the linker.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>The linking process</title>

      <para>Thus the linking process is really two steps; combining
      all object files into one exectuable file and then going through
      each object file to <emphasis>resolve</emphasis> any symbols.
      This usually requires two passes; one to read all the symbol
      definitions and take note of unresolved symbols and a second to
      fix up all those unresolved symbols to the right place.</para>

      <para>The final executable should end up with no unresolved
      symbols; the linker will fail with an error if there are
      any.<footnote> <para>We call this <emphasis>static
      linking</emphasis>.  Dynamic linking is a similar concept done
      at executable runtime, and is described a little later
      on.</para></footnote></para>

    </sect2>

  </sect1>


  <sect1>
    <title>A practical example</title>
    <para></para>
  </sect1>


</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.sgml" "book" "chapter")
End:
-->