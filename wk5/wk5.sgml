<chapter id="wk5">
  
  <title>Virtual Memory</title>

  <sect1>
    <title>What Virtual Memory <emphasis>isn't</emphasis></title>

    <para>Virtual memory is often naively discussed as a way to
    extended your RAM by using the hard drive as extra, slower, system
    memory.  That is, once your system runs out of memory, it flows
    over onto the hard drive which is used as "virtual" memory.</para>

    <para>In modern operating systems, this is commonly referred to as
    <emphasis>swap space</emphasis>, because unused parts of memory as
    swapped out to disk to free up main memory (remember, programs can
    only execute from main memory).
    </para>

    <para>Indeed, the ability to swap out memory to disk is an
    important part of how virtual memory works, but as you will see it
    is not the purpose of virtual memory, but rather a very useful
    side effect!</para>

  </sect1>

  <sect1>
    <title>What virtual memory <emphasis>is</emphasis></title>
    
    <para>Virtual memory is all about making use of <emphasis>address
    space</emphasis>.</para>

    <para>The address space of a processor refers the range of
    possible addresses that it can use when loading and storing to
    memory.  The address space is limited by the width of the
    regisers, since as we know to load an address we need to issue a
    <computeroutput>load</computeroutput> instruction with the address
    to load from in a register.  Most current processors have
    registers that are 32 bits wide; this means the addresses that can
    be stored in a register range from
    <computeroutput>0x00000000</computeroutput> to
    <computeroutput>0xFFFFFFF</computeroutput>.
    2^<superscript>32</superscript> is equal to 4GB, so a 32 bit
    processor can load or store to up to 4GB of memory.</para>

    <sect2>
      <title>64 bit computing</title>

      <para>Most new processors are moving towards 64 bit processors,
    which have registers 64 bits wide.  As an exercise, you should
    work out the address space available to these processors (hint:
    it's big!).</para>
    </sect2>

    <sect2>
      <title>Using the address space</title>
    
      <para>As with most componets of the operating system, virtual
    memory acts as an abstraction between the address space and the
    physical memory available in the system.  This means that when a
    program uses an address that address does not refer to the bits in
    an actual physical location in memory, but must be translated by
    the operating system.</para>
      
    <para>So to this end, we say that all addresses the program uses
      are <emphasis>virtual</emphasis>.  The operating system keeps
      track of virtual addresses and how they point to
      <emphasis>physical address</emphasis>.  When a program does a
      load or store from an address, the processor and operating
      system work together to convert this virtual address to the
      actual address in the system memory chips.
      </para>

      <para>Over time, physical memory becomes
      <emphasis>fragmented</emphasis>, meaning that there are "holes"
      of free space in the physical memory.  Having to work around
      these holes would be at best annoying and would become a serious
      limit to programmers.  By using a virtual address that maps to
      an arbitary physical address the programmer can leave working
      around fragmentation up to the operating system.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Pages</title>

    <para>The address space of even a 32 bit processor is quite large,
    and if the operating system is to keep track of it all it needs to
    divide it into more managable parts.</para>

    <para>The operating system divides the address space into
    <emphasis>pages</emphasis>.  Pages can be many different sizes,
    generally they are around 4KB, but this is not a hard and fast
    rule and they can be much larger.</para>

    <para>The page is the smallest unit of memory that the operating
    system and hardware can deal with.</para>

    <para>Additionally, each page has a number of attributes set by
    the operating system.  Generally, these include read, write and
    execute permissions for the current page.  For example, a page
    must be marked if it contains executable code.</para>

    <figure>
      <title>Virtual memory pages</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="wk5/figures/page.eps" format="EPS">
	</imageobject>
	<imageobject>
	  <imagedata fileref="wk5/figures/page.png" format="PNG">
	</imageobject>
	<textobject>
	  <phrase>Pages point to physical memory</phrase>
	</textobject>
      </mediaobject>
    </figure>

  </sect1>

  <sect1>
    <title>Physical Memory</title>

    <para>Just as the operating system divides the possible address
    space up into pages, it divides the available physical memory up
    into <emphasis>frames</emphasis>.</para>

    <para>A frame is just a hunk of physical memory the same size as
    the system page size.</para>

  </sect1>

  <sect1>
    <title>Pages + Frames = Page Tables</title>

    <para>The job of the operating system is to keep track of which
    page points to which frame.  This information is kept in a
    <emphasis>page table</emphasis> which, in its simplest form, is
    simply a table where each row has a page and an associated
    frame.</para>

    <para>With a 32 bit address space and 4K pages there will be
      1048576 pages in the page table.  Assuming each entry in the
      page table takes up 32 bits (or 4 bytes) we have 1048576 * 4 ==
      4194304 bytes == 4MB of page table data to map the entire
      address space. </para>
    
    <para>Page tables can have many different structures and are
      generally highly optimised, as the process of finding a page in
      the page table can be a lenghtly process.</para>

  </sect1>

  <sect1>
    <title>Virtual Adresses</title>

    <para>When a program accesses memory, it does not know or care
    where the physical memory backing the address is stored.  It knows
    it is up to the operating system to map the address to the right
    place and provide it with the data it wants.</para>

    <para>We call the address the userspace program is using to access
    memory a <emphasis>virtual address</emphasis>.  The virtual
    address consists of two parts; an index to a page in a page table
    and an offset.</para>

    <sect2>
      <title>Page Index</title>

      <para>The index portion of the virtual address is the index
      into the page table.</para>
    </sect2>

    <sect2>
      <title>Offset</title>

      <para>The last bits of the virtual address are called the
      <emphasis>offset</emphasis> which is the location within the
      physical page of the address.  You require enough bits in the
      offset to be able to get to any byte in the page.  For a 4K page
      you require (4K == (4 * 1024) == 4096 ==
      2<superscript>12</superscript> ==) 12 bits.</para>

    </sect2>

    <sect2>
      <title>Virtual Address Translation</title>

      <para>When the operating system needs to find the actual memory
      behind a virtual address, it firstly takes the page pointer
      component of the address and looks it up in the page table.
      This gives a pointer to a physical address, to which the offset
      from the virtual address is added, giving the actual location in
      memory.</para>

      <figure>
	<title>Virtual Address Translation</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="wk5/figures/virtaddress.eps" format="EPS">
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="wk5/figures/virtaddress.png" format="PNG">
	  </imageobject>
	  <textobject>
	    <phrase>Converting a virtual address to a physical address</phrase>
	  </textobject>
	</mediaobject>
      </figure>

    </sect2>
  </sect1>


  <sect1>
    <title>Consequences of virtual addresses, pages and page tables</title>

    <para>Virtual addressing, pages and page tables opens up a number
    of interesting opportunities for the operating system.</para>

    <sect2>
      <title>Individual address spaces</title>
      
      <para>If the operating system gives each process its own page
	table, then every process can pretend that it has access to
	the entire address space available from the processor.  It
	doesn't matter that two processes might use the same address,
	since the page table will map it to a different place in
	physical memory.  Every modern operating system provides each
	process with its own address space like this.</para>
    </sect2>

    <sect2>
      <title>Swap</title>

      <para>We can also now see how the swap memory is implemented.
      If instead of pointing to an area of system memory the page
      pointer can be changed to point to a location on a
      disk.</para>

      <para>When this page is referenced, the operating system needs
      to move it from the disk back into system memory (remember,
      program code can only execute from system memory).  If system
      memory is full, then <emphasis>another</emphasis> page needs to
      be kicked out of system memory and put into the swap disk before
      the required page can be put in memory.  If another process
      wants that page that was just kicked out back again, the process
      repeats.</para>

      <para>This can be a major issue for swap memory.  Loading from
      the harddisk is very slow (compared to operations done in
      memory) and most people will be familiar with sitting infront of
      the computer whilst the hard disk churns and churns whilst the
      system remains unresponsive.</para>

      <sect3>
	<title>mmap</title>

	<para>A different but related process is the
	<computeroutput>mmap</computeroutput>.</para>

      </sect3>

    </sect2>
  
    <sect2>
      <title>Sharing memory</title>

      <para>Usually, each process gets its own page table, so any
      address it uses is mapped to a unique frame in physical memory.
      But what if the operating system points two page table entries
      to the same frame?  This means that this frame will be shared;
      and any changes that one process makes will be visible to the
      other.</para>

      <para>You can see now how threads are implemented.  Remember
      from previously we said that the Linux
      <computeroutput>clone()</computeroutput> function could share as
      much or as little of a new process with the old process as it
      required.  If a process calls
      <computeroutput>clone()</computeroutput> to create a new
      process, but requests that the two processes share the same page
      table, then you effectively have a
      <emphasis>thread</emphasis>.</para>

    </sect2>

  </sect1>

</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.sgml" "book" "chapter")
End:
-->